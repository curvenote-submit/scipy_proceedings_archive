 %\renewcommand{\bottomfraction}{.7}
 %\renewcommand{\textfraction}{.15}
 %\renewcommand{\floatpagefraction}{.66}
 %\renewcommand{\dbltopfraction}{.66}
 %\renewcommand{\dblfloatpagefraction}{.66}
 %\setcounter{topnumber}{9}
 %\setcounter{bottomnumber}{9}
 %\setcounter{totalnumber}{20}
 %\setcounter{dbltopnumber}{9}

 
\newcommand{\makeBasicPlottingFig}{%
\begin{figure*}[tbh]
 \centering
% \includegraphics[width=\linewidth]{basicPlotting}
 \includegraphics[width=1.0\textwidth]{figures/basicPlotting.pdf}
 \caption{A selection of basic plots from PyQtGraph's suite of examples.}
 \label{fig:basicPlotting}
\end{figure*}}

\newcommand{\makePtreeExFig}{%
\begin{figure}[!htbp]
\centering
\includegraphics[width=\columnwidth]{figures/pg_ptree_ex.png}
\caption{Sample use of parameter trees for user interaction, where various image processing parameters can be quickly updated. The displayed image reflects these changes in real-time.}
 \label{fig:ptreeEx}
\end{figure}}

\newcommand{\makeNeuralNetFig}{%
\begin{figure*}
\centering
\includegraphics[width=0.8\textwidth]{figures/neuralNetFig.png}
\caption{Application demonstrating how parameter trees, real-time plotting updates, signal hooks, and more can facilitate rapid prototyping and impacts of architectural changes.}
 \label{fig:neuralNetFig}
\end{figure*}}

\newcommand{\makeLineBenchmarkFig}{%
\begin{figure}[!b]
\centering
\includegraphics[width=\columnwidth]{figures/lineBenchmark.pdf}
\caption{Line speed benchmark. The time to render 1, 10 or 100 lines of data is shown for varying numbers of points per line. All data was created using an AMD 5900x Ryzen 9 CPU. Left: Time per update over points per curve. The thresholds for achieving 10 and 60 frames/s are shown by horizontal lines. Right: Update time per point, plotted over the total number of points. For more than 100,000 points, the line-plotting time becomes dominant, and the results converge to 200\,ns per point for both 10 and 100 curves, while plotting all points as a single curve increases the time to 500--600\,ns per point.}
 \label{fig:lineSpeed}
\end{figure}
}
 %13-inch 
 
\newcommand{\makeMatplotlibComparison}{%
\begin{figure}[bth]
\centering
\includegraphics[width=0.9\columnwidth]{figures/pg-mpl-comparison_no_interpolation.png}
\caption{Performance test with PyQtGraph and Matplotlib widgets embedded in a Qt5 application. Over a wide range of image sizes, PyQtGraph completes drawing approximately 75--150 times faster, taking only 5.4\,ms in this example of a 4000\texttimes4000 image. The test is performed without GPU acceleration in a Microsoft Windows environment, and both libraries are set to sub-sample without interpolation. Free-to-use test images are provided by the \href{https://unsplash.com/}{``Unsplash''} service.} 
\label{fig:mpl}
\end{figure}
}

 \newcommand{\makeARBBenchmarkFig}{
 \begin{figure}[tbh]
 \centering
 \includegraphics[width=\columnwidth]{figures/makeARGBBenchmark.pdf}
 \caption{Image speed benchmark. The time to update an image frame is shown for different data formats. Left: Using optimized NumPy processing (purple lines), the drawing time is log-scale linear with the number of pixels over a wide range. GPU accelerated CUDA processing using CuPy (green lines) describe a more complex relationship with image size. The need to copy data to and from the GPU creates additional overhead, but as image size grows, the faster processing speed becomes sufficient to compensate for that overhead. The choice of various extra processing tasks like LUTs (dashed lines) show the same basic trends. Alternatively, PyQtGraph's image rendering pipeline can be accelerated in Numba is available on the system.  Benchmarks with Numba (blue lines) can be seen as have performance between that of CuPy and NumPy only. Right: For input data in uint16 format, CUDA processing is particularly advantageous and can provide an almost four-fold reduction in drawing time. Benchmarks were performed on an AMD 5900x Ryzen 9 CPU and an NVIDIA RTX 3080 discrete GPU.}
 \label{fig:makeARGB}
 \end{figure}
 }
 
\newcommand{\makeMonitoringFig}{%
\begin{figure}[!htbp]
\centering
\includegraphics[width=\columnwidth]{figures/monitoring_example_vector.pdf}
\caption{Monitoring and diagnostic of a (simulated) experiment with intermittent failures. Incoming data at 100 samples/s for two measurement channels is recorded into a rolling 5,000 point buffer and continuously displayed at 30 frames/s. When a failure is observed, it can quickly be brought into focus with simple mouse interactions (click-and-drag and mousewheel zoom) for inspection, or to record accurate time stamps. Afterwards, a single click returns the view to automatic scaling without loss of any incoming data.}
 \label{fig:monitoring}
\end{figure}
}

